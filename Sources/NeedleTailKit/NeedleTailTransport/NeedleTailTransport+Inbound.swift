//
//  IRCClient+Inbound.swift
//
//
//  Created by Cole M on 4/29/22.
//

import CypherMessaging
import NeedleTailHelpers
import NeedleTailProtocol
#if os(macOS)
import AppKit
#endif

#if canImport(SwiftUI) && canImport(Combine) && (os(macOS) || os(iOS))
@NeedleTailTransportActor
extension NeedleTailTransport {
    func doNotice(recipients: [IRCMessageRecipient], message: String) async throws {
        await respondToTransportState()
    }
}
#endif

@NeedleTailTransportActor
extension NeedleTailTransport {
    
    
    /// We receive the messageId via a **QRCode** from the **Child Device** we will emit this id to the **Master's Client** in order to generate an approval **QRCode**.
    /// - Parameter messageId: The message request identity generated by the **Child Device**
    func receivedRegistryRequest(_ messageId: String) async throws {
#if (os(macOS) || os(iOS))
        emitter?.requestMessageId = messageId
#endif
    }
    
    /// If the approval code matches the code that the requesting device temporarily store it then let the requesting client know that the master devices has approved of the registration of this device.
    func computeApproval(_ code: String) async -> Bool {
        if self.registryRequestId == code {
            self.registryRequestId = ""
            return true
        }
        return false
    }
    
    /// This method is called on the Dispatcher, After the master device adds the new Device locally and then sends it to the server to be saved
    func receivedNewDevice(_ deviceState: NewDeviceState, contacts: [NTKContact]) async throws {
        self.receivedNewDeviceAdded = deviceState
        try await addMasterDevicesContacts(contacts)
#if (os(macOS) || os(iOS))
        guard let emitter = emitter else { return }
        await clearNewDeviceState(emitter)
#endif
    }
    
    func addMasterDevicesContacts(_ contactList: [NTKContact]) async throws {
        for contact in contactList {
            let createdContact = try await ntkBundle.cypher?.createContact(byUsername: contact.username)
            try await createdContact?.setNickname(to: contact.nickname)
        }
    }
    
    @MainActor
    private func clearNewDeviceState(_ emitter: NeedleTailEmitter) {
#if (os(macOS) || os(iOS))
        emitter.qrCodeData = nil
        emitter.showProgress = false
        emitter.dismissRegistration = true
#endif
    }
    
    private func sendMessageTypePacket(_ type: MessageType, nick: NeedleTailNick) async throws {
        let packet = MessagePacket(
            id: UUID().uuidString,
            pushType: .none,
            type: type,
            createdAt: Date(),
            sender: nil,
            recipient: nil,
            message: nil,
            readReceipt: .none
        )
        let encodedData = try BSONEncoder().encode(packet).makeData()
        let type = TransportMessageType.private(.PRIVMSG([.nick(nick)], encodedData.base64EncodedString()))
        try await transportMessage(type)
    }
    
    func doMessage(
        sender: IRCUserID?,
        recipients: [ IRCMessageRecipient ],
        message: String,
        tags: [IRCTags]?
    ) async throws {
        guard let data = Data(base64Encoded: message) else { return }
        let buffer = ByteBuffer(data: data)
        let packet = try BSONDecoder().decode(MessagePacket.self, from: Document(buffer: buffer))
        for recipient in recipients {
            switch recipient {
            case .everything:
                break
            case .nick(_):
                switch packet.type {
                case .publishKeyBundle(_):
                    break
                case .registerAPN(_):
                    break
                case .message:
                    // We get the Message from IRC and Pass it off to CypherTextKit where it will enqueue it in a job and save it to the DB where we can get the message from.
                    try await processMessage(
                        packet,
                        sender: sender,
                        recipient: recipient,
                        messageType: .message,
                        ackType: .messageSent
                    )
                case .multiRecipientMessage:
                    break
                case .readReceipt:
                    guard let receipt = packet.readReceipt else { throw NeedleTailError.nilReadReceipt }
                    switch packet.readReceipt?.state {
                    case .displayed:
                        try await ctcDelegate?.receiveServerEvent(
                            .messageDisplayed(
                                by: receipt.sender.username,
                                deviceId: receipt.sender.deviceId,
                                id: receipt.messageId,
                                receivedAt: receipt.receivedAt
                            )
                        )
                    case .received:
                        try await ctcDelegate?.receiveServerEvent(
                            .messageReceived(
                                by: receipt.sender.username,
                                deviceId: receipt.sender.deviceId,
                                id: receipt.messageId,
                                receivedAt: receipt.receivedAt
                            )
                        )
                    default:
                        break
                    }
                case .ack(let ack):
                    let buffer = ByteBuffer(data: ack)
                    let ack = try BSONDecoder().decode(Acknowledgment.self, from: Document(buffer: buffer))
                    store.setAck(ack.acknowledgment)
                    
                    if store.acknowledgment == .registered("true") {
                        switch transportState.current {
                        case .transportRegistering(channel: let channel, clientContext: let clientContext):
                            let type = TransportMessageType.standard(.USER(clientContext.userInfo))
                            try await transportMessage(type)
                            await transportState.transition(to: .transportOnline(channel: channel, clientContext: clientContext))
                        default:
                            return
                        }
                    } else if store.acknowledgment == .quited {
                        quiting = false
                        await ctDelegate?.shutdown()
                        await transportState.transition(to: .transportOffline)
#if os(macOS)
                        await NSApplication.shared.reply(toApplicationShouldTerminate: true)
#endif
                    } else if store.acknowledgment == .multipartUploadComplete {
                        emitter?.multipartUploadComplete = true
                    }
                case .requestRegistry:
                    switch packet.addDeviceType {
                    case .master:
                        try await receivedRegistryRequest(packet.id)
                    case .child:
                        guard let childDeviceConfig = packet.childDeviceConfig else { return }
                        try await ctcDelegate?.receiveServerEvent(
                            .requestDeviceRegistery(childDeviceConfig)
                        )
                    default:
                        break
                    }
                case .newDevice(let state):
                    guard let contacts = packet.contacts else { return }
                    try await receivedNewDevice(state, contacts: contacts)
                case .notifyContactRemoval:
#if os(iOS) || os(macOS)
                    guard let contact = packet.contacts?.first else { return }
                    guard let foundContact = try await emitter?.cypher?.getContact(byUsername: contact.username) else { return }
                    try await emitter?.removeMessages(from: foundContact)
                    try await foundContact.remove()
#else
                    return
#endif
                default:
                    return
                }
            case .channel(_):
                switch packet.type {
                case .message:
                    // We get the Message from IRC and Pass it off to CypherTextKit where it will enqueue it in a job and save it to the DB where we can get the message from.
                    try await processMessage(packet, sender: sender, recipient: recipient, messageType: .message, ackType: .messageSent)
                default:
                    return
                }
            }
        }
    }
    
    private func processMessage(_
                                packet: MessagePacket,
                                sender: IRCUserID?,
                                recipient: IRCMessageRecipient,
                                messageType: MessageType,
                                ackType: Acknowledgment.AckType,
                                messagePacket: MultipartMessagePacket? = nil
    ) async throws {
        guard let message = packet.message else { throw NeedleTailError.messageReceivedError }
        guard let deviceId = packet.sender else { throw NeedleTailError.senderNil }
        guard let sender = sender?.nick.name else { throw NeedleTailError.nilNickName }
        do {
            try await ctcDelegate?.receiveServerEvent(
                .messageSent(
                    message,
                    id: packet.id,
                    byUser: Username(sender),
                    deviceId: deviceId
                )
            )
        } catch {
            print("CAUGHT_RECEIVE_SERVER_EVENT_ERROR \(error.localizedDescription)")
            return
        }
        
        let acknowledgement = try await createAcknowledgment(ackType, id: packet.id, messagePacket: messagePacket)
        let ackMessage = acknowledgement.base64EncodedString()
            let type = TransportMessageType.private(.PRIVMSG([recipient], ackMessage))
            try await transportMessage(type)
    }
    
    private func createAcknowledgment(_
                                      ackType: Acknowledgment.AckType,
                                      id: String? = nil,
                                      messagePacket: MultipartMessagePacket? = nil
    ) async throws -> Data {
        //Send message ack
        let received = Acknowledgment(acknowledgment: ackType)
        let ack = try BSONEncoder().encode(received).makeData()
        
        let packet = MessagePacket(
            id: id ?? UUID().uuidString,
            pushType: .none,
            type: .ack(ack),
            createdAt: Date(),
            sender: nil,
            recipient: nil,
            message: nil,
            readReceipt: .none,
            multipartMessage: messagePacket
        )
        
        return try BSONEncoder().encode(packet).makeData()
    }
    
    
    func doNick(_ newNick: NeedleTailNick) async throws {}
    
    
    func doMode(nick: NeedleTailNick, add: IRCUserMode, remove: IRCUserMode) async throws {
        var newMode = userMode
        newMode.subtract(remove)
        newMode.formUnion(add)
        if newMode != userMode {
            userMode = newMode
            await respondToTransportState()
        }
    }
    
    
    func doBlobs(_ blobs: [String]) async throws {
        guard let blob = blobs.first else { throw NeedleTailError.nilBlob }
        self.channelBlob = blob
    }
    
    
    func doJoin(_ channels: [IRCChannelName], tags: [IRCTags]?) async throws {
        logger.info("Joining channels: \(channels)")
        await respondToTransportState()
        
        guard let tag = tags?.first?.value else { return }
        self.channelBlob = tag
        
        guard let data = Data(base64Encoded: tag) else  { return }
        
        let onlineNicks = try BSONDecoder().decode([NeedleTailNick].self, from: Document(data: data))
        await plugin?.onMembersOnline(onlineNicks)
    }
    
    func doPart(_ channels: [IRCChannelName], tags: [IRCTags]?) async throws {
        await respondToTransportState()
        
        guard let tag = tags?.first?.value else { return }
        guard let data = Data(base64Encoded: tag) else  { return }
        let channelPacket = try BSONDecoder().decode(NeedleTailChannelPacket.self, from: Document(data: data))
        await plugin?.onPartMessage(channelPacket.partMessage ?? "No Message Specified")
    }
    
    func doIsOnline(_ nicks: [NeedleTailNick]) async throws {
        for nick in nicks {
            print("IS ONLINE", nick)
        }
    }
    
    func doModeGet(nick: NeedleTailNick) async throws {
        await respondToTransportState()
    }
    
    
    //Send a PONG Reply to server When We receive a PING MESSAGE FROM SERVER
    @PingPongActor
    func doPing(_ origin: String, origin2: String? = nil) async throws {
        try await Task.sleep(until: .now + .seconds(5), tolerance: .seconds(2), clock: .suspending)
        try await self.pingPongMessage(.PONG(server: origin, server2: origin2), tags: nil)
    }
    
    private func respondToTransportState() async {
        switch transportState.current {
        case .clientOffline:
            break
        case .clientConnecting:
            break
        case .clientConnected:
            break
        case .transportRegistering(channel: _, clientContext: _):
            break
        case .transportOnline(channel: _, clientContext: _):
            break
        case .transportDeregistering:
            break
        case .transportOffline:
            break
        case .clientDisconnected:
            break
        }
    }
    
    
    func handleInfo(_ info: [String]) async {
        var newArray = [String]()
        if info.first?.contains(Constants.colon) != nil {
            newArray.append(contentsOf: info.dropFirst())
        }
        let filtered = newArray
            .filter{ !$0.isEmpty}
            .joined(separator: Constants.space)
        let infoMessage = filtered.components(separatedBy: Constants.cLF)
            .map { $0.replacingOccurrences(of: Constants.cCR, with: Constants.space) }
            .filter{ !$0.isEmpty}
        logger.info("Server information: \(infoMessage.joined())")
    }
    
    
    func handleTopic(_ topic: String, on channel: IRCChannelName) {
        logger.info("Topic: \(topic), on Channel: \(channel)")
    }
    
    func handleServerMessages(_ messages: [String], type: IRCCommandCode) async {
        var newArray = [String]()
        if messages.first?.contains(Constants.colon) != nil {
            newArray.append(contentsOf: messages.dropFirst())
        }
        let filtered = newArray
            .filter{ !$0.isEmpty}
            .joined(separator: Constants.space)
        let message = filtered.components(separatedBy: Constants.cLF)
            .map { $0.replacingOccurrences(of: Constants.cCR, with: Constants.space) }
            .filter{ !$0.isEmpty}
        logger.info("Server Message: \(message.joined()), type: \(type)")
    }
    
    func doMultipartMedia(_
                          media: String,
                          sender: IRCUserID?
    ) async throws {
        guard let data = Data(base64Encoded: media) else { return }
        let packet = try BSONDecoder().decode(MessagePacket.self, from: Document(data: data))
        guard let messagePacket = packet.multipartMessage else { return }
        guard let nick = self.nick else { return }
        
        try await processMessage(
            packet,
            sender: sender,
            recipient: .nick(nick),
            messageType: .message,
            ackType: .multipartReceived,
            messagePacket: messagePacket
        )
    }
}

